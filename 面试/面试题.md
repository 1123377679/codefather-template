# 面试题

## 说说Java中HashMap的原理

HashMap主要是用来存储键值对的，key:value 在jdk8之前是通过数组+链表的方式组合，到jdk8之后是通过数组+链表+红黑树的方式来进行存储

HashMap是通过hashCode()这个方法来计算哈希值

HashMap的默认容量是16 ，负载因子是0.75 ，如果说存储的数量超过了16*0.75 = 12 ,就会扩容，扩容的话位置是 x2 这种扩容不太好，如果扩容过多会影响性能

## Java中ConcurrentHashMap 1.7和1.8之间有哪些区别?

在1.7的时候是使用的分段锁，每个段都是独立的，默认是16个，所以有16个线程可以并行

在1.8的时候就移出了段，只有在更新链表或者红黑树的时候才会加锁

并且1.7用的还是数组+链表，1.8加上了红黑树

## 为什么jdk8对HashMap进行了红黑树的改动

链表在CRUD过程中如果元素慢慢变多，时间复杂度就会增加

所以引入了红黑树，红黑树是一种二叉平衡树，在元素多的情况下，速度是比链表要快的

链表什么时候转红黑树，如果某个链表的元素大于等于8，并且数组长度大于等于64 就会转红黑树

## Java中有哪些集合类？

两大接口 Collection和Map

List接口和Set接口

Map接口

## 数据库中的脏读、不可重复读、幻读分别是什么意思

脏读：就是一个事务读取到了另一个事务还没有提交的内容

不可重复读：在同一个事务中读取同一个数据两次，但是结果是不同的，比如事务A读取了一段数据，b这个时候修改了这个数据，然后a再次读取的时候发现数据就不一样了

幻读：一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况就是幻读

## Synchronized 和 ReentrantLock 有什么区别？

Synchronized是 Java内置的关键字，实现基本的同步机制，不支持超时，非公平，不可中断，不支持多条件

ReentrantLock 是JUC类库提供的，由JDK1.5引入，可以避免死锁，比较灵活

Synchronized是不能手动解锁的，但是ReentrantLock 可以

基本用Synchronized就可以了，但是如果比较复杂的情况用ReentrantLock 就可以

## 谈谈你对线程池的理解。常用的线程池有哪些

## 2025年9月30日上午面试题

### redis中的击穿穿透雪崩是什么意思，分别怎么解决

- **击穿**：指某个热点key在缓存过期的一瞬间，大量请求同时访问该key，导致请求直接打到数据库，造成数据库压力激增。
- 解决方案
  - 设置热点key永不过期（但需异步更新缓存）。
  - 使用互斥锁（如Redis的SETNX）：只允许一个请求去加载数据，其他请求等待或重试。
  - 采用逻辑过期：在value中存储过期时间，由业务逻辑判断并异步更新。
- **穿透**：查询一个不存在的数据（如恶意请求不存在的key），缓存未命中，请求直接访问数据库。
  - 解决方案
    - 缓存空值（null）并设置较短过期时间，避免重复查询数据库。
    - 使用布隆过滤器（Bloom Filter）快速判断key是否存在，拦截无效请求。
    - 加强参数校验，过滤非法请求（如ID非正数）。
- **雪崩**：大量key在同一时间过期，或Redis服务宕机，导致所有请求直接访问数据库，引发数据库崩溃。

- 解决方案
  - 设置随机过期时间（基础时间+随机值），避免同时失效。
  - 集群部署Redis（主从复制、哨兵模式或集群模式），提高可用性。
  - 服务降级和熔断（如Hystrix）：在缓存失效时限制数据库访问。
  - 持久化缓存：部分热点数据永不过期，通过异步方式更新。

### redis中的常用数据类型

1. **String（字符串）** ：存储文本、数字或二进制数据，常用于缓存、计数器（如INCR/DECR）。
2. **Hash（哈希）** ：存储字段-值对，适合表示对象（如用户信息）。
3. **List（列表）** ：双向链表，支持增删元素，可用于消息队列、最新列表。
4. **Set（集合）** ：无序唯一集合，支持交集、并集，适用于标签、好友关系。
5. **Sorted Set（有序集合）** ：带分数的集合，按分数排序，适用于排行榜、延迟队列。

### redis中常用的场景

1. **缓存**：加速数据访问（如热点数据、页面缓存）。
2. **会话存储（Session）** ：分布式系统共享用户状态。
3. **消息队列**：使用List或Stream实现异步任务、削峰填谷。
4. **排行榜**：Sorted Set实现实时排名（如游戏积分）。
5. **计数器**：String的INCR实现阅读量、点赞数。
6. **分布式锁**：SETNX实现互斥访问。
7. **好友关系/标签**：Set实现共同关注、标签筛选。
8. **限流**：结合Lua脚本限制接口请求频率。
9. **地理位置应用**：Geospatial存储和查询附近地点。

### 订单系统中有亿级别的数据库怎么做分库分表

1. **分库分表策略**：
   - **水平分表**：按订单ID哈希取模（如对1024取模）或按时间范围（如按月分表）。
   - **分库**：每个库部署在不同实例，分散IO压力（如16个库，每个库64张表）。
   - **路由键**：使用订单ID或用户ID作为分片键，确保数据均匀分布。
2. **中间件选择**：
   - 使用ShardingSphere、MyCat等分库分表中间件，透明化路由。
   - 或自研路由层（通过业务代码或代理）。
3. **全局唯一ID**：
   - 雪花算法（Snowflake）生成分布式ID，避免主键冲突。
4. **查询优化**：
   - 避免跨分片查询（如通过用户ID查询订单时，需以用户ID作为分片键）。
   - 冗余数据或使用ES同步数据，支持复杂查询。
5. **扩容方案**：
   - 预留分片（如开始时多分片），或采用一致性哈希减少数据迁移。

### 订单系统中有个导出功能，并发量大概再5000左右，如果再导出的过程中，怎么能不影响用户再小程序的下单

1. **异步导出**：
   - 用户触发导出后，生成任务ID并返回，后台异步处理，完成后通知用户下载。
   - 使用消息队列（如RabbitMQ、Kafka）削峰，控制导出任务并发数。
2. **资源隔离**：
   - 导出服务独立部署，与核心下单服务分离，避免资源竞争。
   - 数据库读写分离：导出查询只读从库，下单写主库。
3. **限流与降级**：
   - 导出接口限流（如令牌桶算法），控制并发请求数（如最多50个导出任务同时运行）。
   - 当系统负载高时，自动延迟或暂停导出任务。
4. **优化查询**：
   - 导出使用分页查询，避免一次性加载大量数据。
   - 添加合适索引，减少数据库压力。
5. **监控与告警**：
   - 监控数据库CPU/IO和导出队列长度，及时调整策略。

### 订单系统中的幂等性

**幂等性**：多次请求与一次请求效果相同（如重复提交订单只产生一个订单）。

#### 实现方案：

1. **唯一业务标识**：
   - 每个请求携带唯一ID（如订单ID+来源），服务器缓存已处理ID，重复请求直接返回结果。
   - 使用数据库唯一索引（如订单号）防止重复插入。
2. **Token机制**：
   - 下单前先获取token（存入Redis），提交时验证token并删除，确保仅一次有效。
3. **状态机**：
   - 订单状态流转（如“待支付→已支付”），只有特定状态才允许操作，避免重复更新。
4. **乐观锁**：
   - 更新订单时带版本号（如`update orders set status=paid where id=123 and version=5`）。
5. **消息去重**：
   - 消息队列（如RocketMQ）支持幂等投递，或消费者自行去重。

**示例流程**：

- 用户下单生成唯一请求ID，服务端校验ID是否已存在（Redis或数据库），若存在则返回已创建订单；否则正常处理。













